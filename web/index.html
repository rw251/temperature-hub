<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
    }

    body {
      height: 90%;
      font-size: 16px;
    }

    button {
      background-color: #4caf50;
      font-size: 20 px;
      border: none;
      color: white;
      padding: 6px 12px;
      text-align: center;
      text-decoration: none;
      display: inline-block;
      margin: 4px 2px;
      cursor: pointer;
    }
    #chart-section {
      height: 80vh;
      max-width: 100%;
    }
    #myChart {
      height: 100% !important;
      width: 100% !important;
      display: block;
    }

    td.sparkline-cell {
      position: relative;
    }
    .tooltip {
      position: absolute;
      background: rgba(0, 0, 0, .7);
      color: #fff;
      padding: 2px 5px;
      font-size: 12px;
      white-space: nowrap;
      z-index: 9999;
      pointer-events: none;
    }

    .sparkline--cursor {
      stroke: orange;
    }

    .sparkline--spot {
      fill: red;
      stroke: red;
    }
  </style>
</head>

<body>
  <!-- Summary Table -->
  <div id="summary-section">
    <h2>Current Room Temperatures</h2>
    <table id="summary-table">
      <thead>
        <tr>
          <th>Room</th>
          <th>Temp (°C)</th>
          <th>Time</th>
          <th>Last 3h</th>
          <th>Trend</th>
        </tr>
      </thead>
      <tbody>
        <!-- Filled by JS -->
      </tbody>
    </table>
  </div>

  <!-- Chart Section (hidden by default) -->
  <div id="chart-section" style="display:none;">
    <canvas id="myChart"></canvas>
    <div id="footer">
      <button id="refresh">Refresh</button>
      <button id="toggle">Toggle</button>
    </div>
  </div>

  <!-- Tab Buttons -->
  <div>
    <button id="show-summary">Summary</button>
    <button id="show-chart">Chart</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.0.1/dist/chart.umd.min.js"></script>
  <script
    src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.0/dist/chartjs-plugin-zoom.min.js"></script>
  <script src="https://cdn.rawgit.com/fnando/sparkline/master/dist/sparkline.js"></script>
  <script type="text/javascript">
    function findClosest(target, tagName) {
      if (target.tagName === tagName) {
        return target;
      }

      while ((target = target.parentNode)) {
        if (target.tagName === tagName) {
          break;
        }
      }

      return target;
    }

    let currentMode = 'dp';
    let chart;
    const ctx = document.getElementById('myChart');

    // Helper to update summary table
    function updateSummaryTable(roomData) {
      const tbody = document.getElementById('summary-table').querySelector('tbody');
      tbody.innerHTML = '';
      Object.entries(roomData).forEach(([room, {id, data:arr}]) => {
        // Collapse to one reading per minute (keep latest)
        const perMinute = {};
        arr.forEach(d => {
          // Round to minute (UTC)
          const minuteKey = new Date(d.dt + 'Z').toISOString().slice(0,16); // e.g. "2024-07-10T13:42"
          perMinute[minuteKey] = d; // overwrite, so latest stays
        });
        const arrPerMinute = Object.values(perMinute).sort((a, b) => new Date(a.dt) - new Date(b.dt));
        
        const latest = arrPerMinute[arrPerMinute.length - 1];
        const prev = arrPerMinute.length > 1 ? arrPerMinute[arrPerMinute.length - 2] : latest;
        
        // Convert UTC time to local time string
        const localTime = new Date(latest.dt + 'Z').toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        // Get last 3 hours of data
        // Get last 3 hours of data
        const now = Date.now();
        const threeHoursAgo = now - 3 * 60 * 60 * 1000;
        const filtered = arrPerMinute
          .filter(d => (new Date(d.dt + 'Z')).getTime() >= threeHoursAgo);

        const minTemp = Math.min(...filtered.map(d => d.temp));
        const maxTemp = Math.max(...filtered.map(d => d.temp));
        const sparkData = filtered
          .map(d => {
            return {name:room, date: d.dt, value: d.temp - minTemp + 0.1, actualValue:d.temp};
          });

        // Calculate trend state using last 3 hours of data
        let trend = '→ Steady';
        if (filtered.length >= 2) {
          const first = filtered[0].temp;
          const last = filtered[filtered.length - 1].temp;
          const prev = filtered[filtered.length - 2].temp;
          const delta = last - first;
          const prevDelta = last - prev;
          const threshold = 0.05; // Ignore changes smaller than this

          // Find local min/max in the last 3 hours
          const temps = filtered.map(d => d.temp);
          const minIdx = temps.indexOf(minTemp);
          const maxIdx = temps.indexOf(maxTemp);

          if (Math.abs(prevDelta) < threshold && Math.abs(delta) < threshold) {
            trend = '→ Steady';
          } else if (
            minIdx > 0 && minIdx < filtered.length - 1 &&
            last > prev && Math.abs(last - minTemp) < threshold
          ) {
            trend = '↘↗ Inflected Low';
          } else if (
            maxIdx > 0 && maxIdx < filtered.length - 1 &&
            last < prev && Math.abs(last - maxTemp) < threshold
          ) {
            trend = '↗↘ Inflected High';
          } else if (delta > threshold) {
            trend = '↗↑ Rising';
          } else if (delta < -threshold) {
            trend = '↘↓ Falling';
          } else {
            trend = '→ Steady';
          }
        }
        

        // Generate a unique id for the sparkline canvas
        const sparkId = `spark-${room.replace(/\s+/g, '-')}`;

        const row = `<tr>
          <td>${room}</td>
          <td>${latest.temp}</td>
          <td>${localTime}</td>
          <td class="sparkline-cell">
            <svg class="spark-${room}" width="100" height="20" stroke-width="2" stroke="blue" fill="rgba(0, 0, 255, .2)"></svg>
            <span class="tooltip" hidden="true"></span>
          </td>
          <td>${trend}</td>
        </tr>`;
        tbody.insertAdjacentHTML('beforeend', row);

        var options = {
          onmousemove(event, datapoint) {
            var svg = findClosest(event.target, "svg");
            var tooltip = svg.nextElementSibling;
            var date = (new Date(datapoint.date)).toISOString().substring(11, 16); // HH:mm format


            tooltip.hidden = false;
            tooltip.textContent = `${date}: ${datapoint.actualValue.toFixed(2)}°C`;
            tooltip.style.top = `${event.offsetY}px`;
            tooltip.style.left = `${event.offsetX + 20}px`;
          },

          onmouseout() {
            var svg = findClosest(event.target, "svg");
            var tooltip = svg.nextElementSibling;

            tooltip.hidden = true;
          }
        };

        sparkline.sparkline(document.querySelector(`.spark-${room}`), sparkData, options);
      });
    }

// Parse data and prepare for both summary and chart
    function parseData(raw, mode) {
      const rooms = {};
      const chartConfig = {
        type: 'line',
        data: { datasets: [] },
        options: {
          maintainAspectRatio: false,
          interaction: { intersect: false, mode: 'nearest' },
          stacked: true,
          responsive: true,
          spanGaps: true,
          elements: { point: { radius: 0 } },
          plugins: { zoom: {
              limits: {
                x: { min: 'original', max: 'original' },
              },
              pan: {
                enabled: true,
                mode: 'x',
                onPanStart: (e) => {
                  if (e.chart.getZoomLevel() <= 1) return false;
                },
              },
              zoom: {
                wheel: {
                  enabled: true,
                },
                pinch: {
                  enabled: true,
                },
                mode: 'x',
              },
            },
          },
          scales: {
            x: { type: 'time', time: {
                displayFormats: {
                  millisecond: 'dd HH',
                  second: 'dd HH',
                  minute: 'dd HH',
                  hour: 'dd HH',
                  day: 'MMM dd',
                  week: 'MMM dd',
                  month: 'MMM',
                  quarter: 'MMM',
                  year: 'yyyy MMM',
                },
              } },
            y: {
              type: 'linear',
              display: true,
              stacked: false,
              position: 'left',
              min: 0,
              title: {
                text: mode === 'dp' ? 'Dew Point (C)' : 'Temperature (C)',
                display: true,
              },
            },
          },
        },
      };

      raw.split('\n')
        .filter(x => x.trim().length > 5)
        .forEach(line => {
          const [dt, loc, col, temp, hum, dp, battery] = line.split('\t');
          if (!rooms[loc]) {
            rooms[loc] = {id: Object.keys(rooms).length + 1, data:[]};
            chartConfig.data.datasets.push({ label: loc, data: [] });
          }
          rooms[loc].data.push({ dt, temp: parseFloat(temp), dp: parseFloat(dp) });
          chartConfig.data.datasets[rooms[loc].id - 1].data.push({
            x: dt,
            y: mode === 'dp' ? dp : temp
          });
        });
      return { rooms, chartConfig };
    }

    // Render summary and chart
    function renderAll(mode) {
      fetch('data/data.txt').then(x => x.text()).then(data => {
        const { rooms, chartConfig } = parseData(data, mode);
        updateSummaryTable(rooms);
        if (chart) chart.destroy();
        chart = new Chart(ctx, chartConfig);
      });
    }

    // Tab logic
    document.getElementById('show-summary').onclick = () => {
      document.getElementById('summary-section').style.display = '';
      document.getElementById('chart-section').style.display = 'none';
    };
    document.getElementById('show-chart').onclick = () => {
      document.getElementById('summary-section').style.display = 'none';
      document.getElementById('chart-section').style.display = '';
    };

    document.getElementById('refresh').addEventListener('click', (e) => {
      window.location.reload();
    });
    document.getElementById('toggle').addEventListener('click', (e) => {
      currentMode = currentMode === 'dp' ? 'temp' : 'dp';
      renderAll(currentMode);
    });
    // Initial render
    renderAll(currentMode);
  </script>
</body>

</html>